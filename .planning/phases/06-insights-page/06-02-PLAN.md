---
phase: 06-insights-page
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/insights/types.ts
  - src/lib/insights/commands.ts
  - src-tauri/src/lib.rs
autonomous: true

must_haves:
  truths:
    - "The app can compute an insights dashboard payload for a given library folder without reading transcripts one-by-one in React."
    - "The insights payload includes KPI totals and chart-ready series/bucket data."
  artifacts:
    - path: "src/lib/insights/types.ts"
      provides: "Typed insights dashboard payload contract"
    - path: "src/lib/insights/commands.ts"
      provides: "invoke() wrapper for get_library_insights"
    - path: "src-tauri/src/lib.rs"
      provides: "Tauri command get_library_insights (aggregates library metrics)"
  key_links:
    - from: "src/lib/insights/commands.ts"
      to: "src-tauri/src/lib.rs"
      via: "invoke('get_library_insights')"
      pattern: "get_library_insights"
---

<objective>
Add a single Tauri command that returns a normalized Insights dashboard payload (KPIs + time series + breakdowns), plus a typed invoke() wrapper.

Purpose: INSIGHTS-02/03 require aggregated stats; computing them in Rust avoids UI jank and avoids N transcript reads.
Output: `get_library_insights` command + TS types + TS wrapper.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src-tauri/src/lib.rs
@src/lib/fs/commands.ts
@src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define insights payload types + command wrapper</name>
  <files>src/lib/insights/types.ts, src/lib/insights/commands.ts</files>
  <action>
Create a small insights client module under `src/lib/insights/`.

`src/lib/insights/types.ts` (new):
- Define a compact, chart-friendly payload contract used by the Insights page:
  - `InsightsRangePreset = '7d' | '30d' | '90d' | 'all'`
  - `InsightsSeriesPoint` with:
    - `dayStartUnix: number` (unix seconds, UTC day start)
    - `recordingSeconds: number`
    - `transcribedSeconds: number`
    - `recordings: number`
  - `InsightsBucket` with:
    - `id: string` (stable)
    - `label: string`
    - `count: number`
    - `seconds: number`
  - `InsightsKpis` with:
    - `totalRecordings: number`
    - `totalRecordingSeconds: number`
    - `transcribedRecordings: number`
    - `transcribedSeconds: number`
    - `transcriptionCoveragePct: number` (0-100)
  - `InsightsRecordingRow` for the "Recent" table with:
    - `id`, `name`, `path`, `mtimeUnix: number`, `durationSeconds: number | null`, `hasTranscript: boolean`, `language: string`
  - `LanguageDistributionItem` with `language`, `count`, `transcribedSeconds`
  - `FileTypeDistributionItem` with `ext`, `count`, `seconds`
  - `LibraryInsightsPayload` that bundles:
    - `preset: InsightsRangePreset`
    - `kpis: InsightsKpis`
    - `series: InsightsSeriesPoint[]`
    - `durationBuckets: InsightsBucket[]`
    - `languageDistribution: LanguageDistributionItem[]`
    - `fileTypeDistribution: FileTypeDistributionItem[]`
    - `recent: InsightsRecordingRow[]`

`src/lib/insights/commands.ts` (new):
- Export `getLibraryInsights(args)` which calls:
  - `invoke<LibraryInsightsPayload>('get_library_insights', { folderPath, preset, transcriptionMetaByPath })`
- Keep it as a thin wrapper; do not format dates or build chart points here.

Notes:
- Use named exports only.
- Keep types and commands isolated to this folder.
  </action>
  <verify>Type-check: `npm run build` succeeds and `getLibraryInsights` is importable.</verify>
  <done>Insights payload contract exists and has a typed invoke() wrapper.</done>
</task>

<task type="auto">
  <name>Task 2: Implement get_library_insights Tauri command (Rust aggregation)</name>
  <files>src-tauri/src/lib.rs</files>
  <action>
Implement a new Tauri command in `src-tauri/src/lib.rs`:

Command:
- Name: `get_library_insights`
- Signature (Rust-side intent): accepts
  - `folder_path: String`
  - `preset: String` (one of `'7d' | '30d' | '90d' | 'all'`)
  - `transcription_meta_by_path: Option<HashMap<String, { language: String, transcription_seconds: Option<f64> }>>`

Behavior:
1. Scan the folder recursively for audio files using the same extensions as `scan_folder_for_audio`.
2. For each audio file:
   - Determine `has_transcript` by checking `path.with_extension("txt")` exists.
   - Determine `language`:
     - If `has_transcript` and a meta entry exists for the path, use its language.
     - Else if `has_transcript`, use `'unknown'`.
     - Else use `'unknown'`.
   - Determine `transcribed_seconds`:
     - If `has_transcript` and meta has `transcription_seconds`, use it.
     - Else if `has_transcript` and audio duration exists, use audio duration.
     - Else `0`.
3. Apply the selected range preset by filtering recordings based on `mtime` (unix seconds):
   - `7d`: include records with `mtime >= now - 7*86400`
   - `30d`: include records with `mtime >= now - 30*86400`
   - `90d`: include records with `mtime >= now - 90*86400`
   - `all`: include all
4. Compute:
   - KPIs totals.
   - `series` bucketed by day start unix seconds (UTC): `dayStartUnix = mtime - (mtime % 86400)`.
   - Duration buckets (example bins; keep stable IDs):
     - `0-2m`, `2-5m`, `5-15m`, `15m+` using audio duration seconds.
   - File type distribution by extension (lowercased).
   - Language distribution by `language` (lowercased, but preserve `'unknown'`).
   - Recent recordings list (top 10 by mtime desc) with `hasTranscript`, `language`.

Implementation constraints:
- Avoid adding new Rust dependencies (no chrono); use unix math.
- Reuse the existing duration read logic (`read_audio_duration`) and scan logic where possible (copy is acceptable if that keeps changes minimal).
- Return a JSON-serializable struct matching `LibraryInsightsPayload` fields and naming (serde default is fine).

Registration:
- Add `get_library_insights` to the `invoke_handler` list in the same file.
  </action>
  <verify>
Rust compile: `cargo check` in `src-tauri/` succeeds.
  </verify>
  <done>The frontend can invoke `get_library_insights` and receive a fully-populated payload for rendering charts and KPIs.</done>
</task>

</tasks>

<verification>
- `cargo check` passes.
- `npm run build` passes.
- `get_library_insights` appears in `tauri::generate_handler![...]`.
</verification>

<success_criteria>
- A single invoke returns all KPI + chart series data for the Insights page.
- Payload supports language distribution via optional metadata map input.
</success_criteria>

<output>
After completion, create `.planning/phases/06-insights-page/06-02-SUMMARY.md`
</output>
