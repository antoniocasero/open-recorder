---
phase: 01-transcription-mvp
plan: 05
type: execute
wave: 4
depends_on: ["01-02", "01-03", "01-04"]
files_modified:
  - src-tauri/src/commands/transcription.rs
  - src/components/RecordingsList.tsx
autonomous: false
user_setup: []

must_haves:
  truths:
    - "User gets clear error messages for missing API key, network issues, unsupported formats"
    - "App validates file size before sending to API"
    - "Transcription works for common audio formats (mp3, m4a, wav)"
    - "Complete transcription flow works end‑to‑end"
  artifacts:
    - path: "src-tauri/src/commands/transcription.rs"
      provides: "Enhanced error mapping and file validation"
      contains: "File size validation"
    - path: "src/components/RecordingsList.tsx"
      provides: "Error state display and retry logic"
      contains: "Retry"
  key_links:
    - from: "src-tauri/src/commands/transcription.rs"
      to: "user‑friendly error messages"
      via: "TranscriptionError enum"
      pattern: "MissingApiKey|FileError|ApiError"
    - from: "src/components/RecordingsList.tsx"
      to: "error toast"
      via: "toast.error"
      pattern: "toast\\.error"
---

<objective>
Polish error handling, add file validation, and perform end‑to‑end verification of the transcription feature.

Purpose: Ensure robust error messaging, prevent common failures, and validate the complete user flow.
Output: Improved error handling, file validation, and verified transcription MVP.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-transcription-mvp/01-RESEARCH.md
@.planning/phases/01-transcription-mvp/01-01-SUMMARY.md
@.planning/phases/01-transcription-mvp/01-02-SUMMARY.md
@.planning/phases/01-transcription-mvp/01-03-SUMMARY.md
@.planning/phases/01-transcription-mvp/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance backend error mapping</name>
  <files>src-tauri/src/commands/transcription.rs</files>
  <action>
    Improve error handling in `transcribe_audio_inner` to provide more specific error messages.
    
    1. Extend `TranscriptionError` enum to distinguish more cases:
    
    ```rust
    #[derive(Debug, Error)]
    pub enum TranscriptionError {
        #[error("Missing API key: OPENAI_API_KEY environment variable not set")]
        MissingApiKey,
        #[error("File not found: {0}")]
        FileNotFound(String),
        #[error("File too large: {0} (max 25 MB)")]
        FileTooLarge(String),
        #[error("Unsupported audio format. Supported: mp3, m4a, wav, flac, ogg, aac")]
        UnsupportedFormat,
        #[error("OpenAI API error: {0}")]
        ApiError(String),
        #[error("Network error: {0}")]
        NetworkError(String),
        #[error("Transcription failed: {0}")]
        TranscriptionFailed(String),
        #[error("Failed to save transcript: {0}")]
        SaveError(String),
    }
    ```
    
    2. Add validation for file extension before sending to API (optional but helpful):
    
    ```rust
    fn is_supported_format(path: &PathBuf) -> bool {
        if let Some(ext) = path.extension() {
            let ext = ext.to_string_lossy().to_lowercase();
            matches!(ext.as_str(), "mp3" | "m4a" | "wav" | "flac" | "ogg" | "aac")
        } else {
            false
        }
    }
    ```
    
    3. Integrate validation into `transcribe_audio_inner`:
    
    ```rust
    if !is_supported_format(&path) {
        return Err(TranscriptionError::UnsupportedFormat);
    }
    ```
    
    4. Map `reqwest::Error` to `NetworkError` and `OpenAIError` variants accordingly.
    
    **Why:** Gives users actionable feedback instead of generic "something went wrong".
  </action>
  <verify>Error enum includes new variants; validation functions compile</verify>
  <done>Backend provides specific error messages for common failure modes</done>
</task>

<task type="auto">
  <name>Task 2: Add retry button for failed transcriptions</name>
  <files>src/components/RecordingsList.tsx</files>
  <action>
    Enhance the transcription button to show an error state with retry option.
    
    In `RecordingsList.tsx`, modify the button rendering logic:
    
    ```tsx
    {transcriptionStates[recording.id]?.status === 'error' ? (
      <div className="flex items-center gap-1 ml-auto">
        <span className="text-xs text-red-400">
          {transcriptionStates[recording.id].error?.substring(0, 30)}…
        </span>
        <button
          onClick={(e) => {
            e.stopPropagation()
            handleTranscribe(recording)
          }}
          className="px-2 py-1 text-xs bg-red-900/30 border border-red-800 rounded hover:bg-red-900/50"
        >
          Retry
        </button>
      </div>
    ) : (
      <button
        onClick={(e) => {
          e.stopPropagation()
          handleTranscribe(recording)
        }}
        disabled={transcriptionStates[recording.id]?.status === 'loading'}
        className="flex items-center gap-1 ml-auto px-2 py-1 bg-[#2a2a2a] rounded border border-[#333] hover:bg-[#333] disabled:opacity-50 disabled:cursor-not-allowed"
      >
        {transcriptionStates[recording.id]?.status === 'loading' ? (
          <Loader className="w-3 h-3 animate-spin" />
        ) : (
          <FileText className="w-3 h-3" />
        )}
        <span className="text-xs">
          {transcriptionStates[recording.id]?.status === 'loading' ? 'Transcribing...' : 'Transcribe'}
        </span>
      </button>
    )}
    ```
    
    **Why:** Allows users to recover from transient errors without restarting the app.
  </action>
  <verify>Error state shows error snippet and retry button; retry works</verify>
  <done>Users can retry failed transcriptions directly from the list</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: End‑to‑end verification</name>
  <what-built>Complete transcription feature: backend command, frontend button, modal, toast, error handling</what-built>
  <how-to-verify>
    1. Set `OPENAI_API_KEY` environment variable (if not already).
    2. Start the app with `npm run tauri:dev`.
    3. Choose a folder containing at least one MP3, M4A, or WAV file (small, &lt;25 MB).
    4. Click the "Transcribe" button next to a recording.
    5. Observe:
       - Button shows spinner ("Transcribing…")
       - Success toast appears after completion
       - Modal opens with transcript and word timestamps
       - Transcript .txt file exists next to original audio file
    6. Test error cases:
       - Unset API key → error toast with clear message
       - Unsupported file format → error toast (if validation added)
       - Network offline → error toast
    7. Verify modal interactions: copy, download, close.
  </how-to-verify>
  <resume-signal>Type "verified" if transcription works correctly, or describe any issues.</resume-signal>
</task>

</tasks>

<verification>
- All previously built components still work.
- Error mapping produces user‑friendly messages.
- File size validation prevents sending oversized files.
</verification>

<success_criteria>
1. Backend error enum includes specific variants for common failures.
2. Frontend shows retry button for errors.
3. End‑to‑end transcription flow passes manual verification.
</success_criteria>

<output>
After completion, create `.planning/phases/01-transcription-mvp/01-05-SUMMARY.md`
</output>