---
phase: 02-transcript-management-enhancements
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/RecordingsList.tsx
  - src-tauri/src/commands/transcription.rs
  - src/lib/transcription/commands.ts
autonomous: true
must_haves:
  truths:
    - "User can select multiple recordings and transcribe them in batch"
  artifacts:
    - path: "src/components/RecordingsList.tsx"
      provides: "Multi-select UI with checkboxes and batch transcribe button"
      min_lines: 200
      contains: "checkbox"
    - path: "src-tauri/src/commands/transcription.rs"
      provides: "Batch transcription command processing multiple files"
      contains: "transcribe_audio_batch"
    - path: "src/lib/transcription/commands.ts"
      provides: "Frontend wrapper for batch transcription command"
      contains: "transcribeAudioBatch"
  key_links:
    - from: "src/components/RecordingsList.tsx"
      to: "src/lib/transcription/commands.ts"
      via: "import and invoke"
      pattern: "transcribeAudioBatch"
    - from: "src-tauri/src/commands/transcription.rs"
      to: "src-tauri/src/commands/transcription.rs::transcribe_audio"
      via: "function call"
      pattern: "transcribe_audio"
---

<objective>
Add batch transcription capability: user can select multiple recordings and transcribe them all at once.

Purpose: Improve efficiency for users with many recordings by allowing bulk processing.
Output: Multi-select UI in RecordingsList, backend batch command, progress feedback.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 established transcription command and UI patterns
@src-tauri/src/commands/transcription.rs
@src/lib/transcription/commands.ts
@src/components/RecordingsList.tsx
@src/components/TranscriptionModal.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add multi-select UI to RecordingsList</name>
  <files>src/components/RecordingsList.tsx</files>
  <action>
1. Add state for selected recording IDs (Set or array) using useState.
2. Add checkbox input for each recording item:
   - Place checkbox before the play icon.
   - Use controlled component: checked={selectedIds.has(recording.id)} onChange={() => toggleSelection(recording.id)}
   - Style with Tailwind: w-4 h-4 accent-orange-500.
3. Add "Select All" toggle button in header area (optional but nice).
4. Add "Transcribe Selected" button that appears when at least one recording is selected:
   - Position near the list header.
   - Disabled during transcription.
   - onClick calls handleBatchTranscribe.
5. Implement toggleSelection function to add/remove IDs.
6. Ensure checkbox clicks don't trigger row selection (e.stopPropagation).

Keep existing per‑recording transcribe button (for single transcription). The new batch button should be separate.

Reference existing pattern: per‑recording state uses transcriptionStates map. For batch, we can reuse that map or create separate batch state.
  </action>
  <verify>
- Run dev server (npm run tauri dev) and verify checkboxes appear.
- Select multiple recordings, see "Transcribe Selected" button appear.
- Click button and observe console log (placeholder).
- Checkboxes can be toggled independently.
  </verify>
  <done>
RecordingsList renders checkboxes, selection state works, batch button appears when items selected.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create batch transcription backend command</name>
  <files>src-tauri/src/commands/transcription.rs</files>
  <action>
1. Add a new public function `transcribe_audio_batch` with #[tauri::command] attribute.
   - Signature: `async fn transcribe_audio_batch(paths: Vec<PathBuf>) -> Result<Vec<Result<Transcript, String>>, String>`
   - Returns a vector of results for each file; outer Result for overall errors (e.g., missing API key).
2. Implement sequential processing:
   - Iterate over paths.
   - For each path, call `transcribe_audio_inner(path).await`.
   - Map each result to `Result<Transcript, String>` (convert TranscriptionError to string).
   - Collect into vector.
   - Return Ok(vector).
3. Consider adding concurrency limit (optional). For simplicity, do sequential.
4. Register the command in `src-tauri/src/lib.rs` (add to invoke_handler). Check existing pattern: `invoke_handler![pick_folder, scan_folder_for_audio, transcribe_audio]` – add `transcribe_audio_batch`.
5. Ensure error mapping: Use `map_err(|e| e.to_string())` for outer result.

Note: The command will be called with multiple file paths; each transcription may take time. We'll add progress events later.
  </action>
  <verify>
- Compile Rust project (`cargo check`) to ensure no syntax errors.
- Test command via Tauri devtools or create a minimal test in Rust (optional).
- Verify registration in lib.rs.
  </verify>
  <done>
Batch command compiles, registered, and can be invoked from frontend with array of paths.
  </done>
</task>

<task type="auto">
  <name>Task 3: Connect frontend batch UI with backend and add progress feedback</name>
  <files>src/components/RecordingsList.tsx, src/lib/transcription/commands.ts</files>
  <action>
1. In `src/lib/transcription/commands.ts`, add wrapper function:
   ```
   export async function transcribeAudioBatch(filePaths: string[]): Promise<Array<Transcript | string>> {
     return invoke('transcribe_audio_batch', { paths: filePaths })
   }
   ```
   Return type matches backend: array of either Transcript objects or error strings.
2. In RecordingsList.tsx, implement `handleBatchTranscribe`:
   - Get selected recording paths from recordings array.
   - Call `transcribeAudioBatch(paths)`.
   - While processing, show loading indicator (maybe a progress bar or spinner).
   - Update transcriptionStates for each recording as they complete (since backend returns after all, we can iterate results).
   - Show toast notifications: success for successful ones, error for failures.
   - Clear selection after completion.
3. Add a simple progress indicator: display "Transcribing X of Y..." while waiting.
4. Use existing toast system (`react-hot-toast`).

Consider UX: Show a modal with progress details? Simpler: show a single toast with dynamic message. Could also update each recording's status individually using transcriptionStates map (set 'loading' then 'success'/'error').
  </action>
  <verify>
- Select multiple recordings, click "Transcribe Selected", see loading indicator.
- Observe network requests to OpenAI (if API key present).
- Receive toast notifications for each result.
- TranscriptionStates updated per recording.
  </verify>
  <done>
Batch transcription works end‑to‑end: user can select multiple recordings, start batch, see progress, and get results.
  </done>
</task>

</tasks>

<verification>
1. Start app, choose folder with multiple audio files.
2. Select checkboxes for at least two recordings.
3. Click "Transcribe Selected" button.
4. Observe progress feedback (loading state).
5. After completion, verify each selected recording has transcript available (button changes to "View Transcript" or similar).
6. Check that sidecar .txt files are created for each successfully transcribed file.
7. Verify error handling: if one transcription fails, others continue.
</verification>

<success_criteria>
- Batch transcription UI is functional and intuitive.
- Backend command processes multiple files sequentially.
- User receives clear feedback during and after batch operation.
- No regression to single‑file transcription.
</success_criteria>

<output>
After completion, create `.planning/phases/02-transcript-management-enhancements/02-01-SUMMARY.md`
</output>