---
phase: 02-transcript-management-enhancements
plan: 03
type: execute
wave: 2
depends_on: []
files_modified:
  - src/components/Dashboard.tsx
  - src-tauri/src/commands/transcription.rs
  - src/lib/transcription/commands.ts
  - src/components/RecordingsList.tsx (optional, for highlighting)
autonomous: true
must_haves:
  truths:
    - "User can search within transcript content for keywords"
  artifacts:
    - path: "src/components/Dashboard.tsx"
      provides: "Search input field and results display"
      contains: "search.*transcript"
    - path: "src-tauri/src/commands/transcription.rs"
      provides: "Read transcript file command"
      contains: "read_transcript"
    - path: "src/lib/transcription/commands.ts"
      provides: "Frontend wrapper for reading transcript"
      contains: "readTranscript"
  key_links:
    - from: "src/components/Dashboard.tsx"
      to: "src/lib/transcription/commands.ts"
      via: "readTranscript import and call"
      pattern: "readTranscript"
    - from: "src/components/Dashboard.tsx"
      to: "src/components/RecordingsList.tsx"
      via: "filtered recordings prop"
      pattern: "search.*filter"
---

<objective>
Add search functionality to find recordings by transcript content.

Purpose: Help users locate specific conversations or topics within their transcribed recordings.
Output: Search bar in Dashboard, backend command to read transcript files, client‑side search with highlighting.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing recordings list and transcription states
@src/components/Dashboard.tsx
@src/components/RecordingsList.tsx
@src/lib/transcription/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add backend command to read transcript file</name>
<files>src-tauri/src/commands/transcription.rs</files>
<action>
1. Add a new public function `read_transcript` with #[tauri::command] attribute.
   - Signature: `async fn read_transcript(path: PathBuf) -> Result<String, String>`
   - `path` is the audio file path; reads sidecar .txt file (`path.with_extension("txt")`).
2. Implementation:
   - Check if transcript file exists.
   - Read entire file content as string.
   - Return Ok(content) or error string if file not found or IO error.
3. Register command in `src-tauri/src/lib.rs` invoke_handler.
4. Ensure error messages are user‑friendly.

This command will be used to load transcript text for recordings that haven't been transcribed in the current session.
</action>
<verify>
- Compile Rust project (`cargo check`).
- Test command via Tauri devtools with a known transcript file.
- Verify it returns file content.
</verify>
<done>
Read transcript command compiles, registered, and can retrieve transcript text from sidecar file.
</done>
</task>

<task type="auto">
<name>Task 2: Add search UI to Dashboard</name>
<files>src/components/Dashboard.tsx</files>
<action>
1. Add search state: `searchQuery` (string) and `searchResults` (array of recording IDs) using useState.
2. Add search input component in Dashboard header (above or below "Sync Device" button).
   - Use `<input type="text" placeholder="Search transcripts…">` with Tailwind styling.
   - Add debounced onChange handler (use `useDebounce` hook or setTimeout). Simpler: on `onKeyUp` trigger search after short delay.
3. Add a clear button (X) when search query is non‑empty.
4. Display search result count: "X results" next to input.
5. Modify RecordingsList to accept a `filteredIds` prop (optional) to highlight or only show matching recordings. Decide: either filter the list to only matching recordings, or keep all but highlight matches. We'll start with filtering.

Implementation steps:
- In Dashboard, when searchQuery changes, run `performSearch`.
- `performSearch` will iterate over recordings and check if transcript matches (using existing transcriptionStates and lazy loading via readTranscript).
- Update searchResults with IDs of matches.
- Pass `searchResults` to RecordingsList as `highlightedIds` or use to filter.
</action>
<verify>
- Start app, type in search box, see UI updates.
- Clear button appears when text entered.
- No errors in console.
</verify>
<done>
Dashboard has functional search input with clear button and result count.
</done>
</task>

<task type="auto">
<name>Task 3: Implement search logic with lazy loading</name>
<files>src/components/Dashboard.tsx, src/lib/transcription/commands.ts</files>
<action>
1. Create a helper function `getTranscriptText(recording): Promise<string | null>`:
   - First check if recording has transcript in transcriptionStates (success).
   - If not, call `readTranscript(recording.path)` to load from file.
   - Cache result to avoid repeated calls.
   - Return transcript text or null if no transcript exists.
2. Implement `performSearch`:
   - For each recording, await `getTranscriptText`.
   - If transcript exists, check if `transcript.toLowerCase().includes(query.toLowerCase())`.
   - If matches, add recording.id to results.
3. Add loading state during search (especially when loading many files).
4. Update RecordingsList to only show matching recordings when search is active (or highlight them). We'll choose filtering: pass `filteredRecordings = recordings.filter(r => searchResults.includes(r.id))` to RecordingsList.
5. Add message when no results found.
6. Ensure search is cancellable (if user types new query before previous completes).

Performance considerations: limit concurrent reads to maybe 5 at a time. Use simple loop with async/await for now.
</action>
<verify>
- With at least one transcribed recording, type a word that appears in transcript.
- See list filter to only that recording.
- Clear search, all recordings reappear.
- Test with recording that has transcript file but not yet loaded in session.
</verify>
<done>
Search works end‑to‑end: user can type keywords, see matching recordings filtered, and transcripts are loaded from file when needed.
</done>
</task>

</tasks>

<verification>
1. Start app with several transcribed recordings.
2. Type a distinctive word from one transcript into search box.
3. Observe list filters to show only matching recording(s).
4. Clear search, all recordings reappear.
5. Test with recording that hasn't been transcribed in this session but has sidecar .txt file.
6. Verify search works across all transcript content.
</verification>

<success_criteria>
- Search input is responsive and intuitive.
- Transcripts are loaded from sidecar files when not in memory.
- Filtering works correctly (no false positives/negatives).
- No performance degradation with moderate number of recordings.
</success_criteria>

<output>
After completion, create `.planning/phases/02-transcript-management-enhancements/02-03-SUMMARY.md`
</output>