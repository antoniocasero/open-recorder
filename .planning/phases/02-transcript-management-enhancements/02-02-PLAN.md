---
phase: 02-transcript-management-enhancements
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/TranscriptionModal.tsx
  - src-tauri/src/commands/transcription.rs
  - src/lib/transcription/commands.ts
autonomous: true
must_haves:
  truths:
    - "User can edit transcript text directly in the app"
  artifacts:
    - path: "src/components/TranscriptionModal.tsx"
      provides: "Edit mode UI with textarea, save, cancel buttons"
      contains: "editMode"
    - path: "src-tauri/src/commands/transcription.rs"
      provides: "Save edited transcript command"
      contains: "save_transcript"
    - path: "src/lib/transcription/commands.ts"
      provides: "Frontend wrapper for saving transcript"
      contains: "saveTranscript"
  key_links:
    - from: "src/components/TranscriptionModal.tsx"
      to: "src/lib/transcription/commands.ts"
      via: "saveTranscript import and call"
      pattern: "saveTranscript"
    - from: "src-tauri/src/commands/transcription.rs::save_transcript"
      to: "std::fs::write"
      via: "file write"
      pattern: "write.*txt"
---

<objective>
Enable in‑app editing of transcript text with ability to save changes back to the sidecar .txt file.

Purpose: Allow users to correct transcription errors or add notes without leaving the app.
Output: Edit mode in TranscriptionModal, save command, persistent changes.
</objective>

<execution_context>
@~/.opencode/get-shit-done/workflows/execute-plan.md
@~/.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Existing transcription display and sidecar file pattern
@src/components/TranscriptionModal.tsx
@src-tauri/src/commands/transcription.rs
@src/lib/transcription/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add edit mode UI to TranscriptionModal</name>
  <files>src/components/TranscriptionModal.tsx</files>
  <action>
1. Add `editMode` state (boolean) and `editedText` state (string) using useState.
2. Add "Edit" button next to Copy/Download buttons in footer.
   - Button text: "Edit" (or pencil icon).
   - When clicked: set editMode true, copy transcript.text into editedText.
3. In edit mode:
   - Replace the plain text block with a `<textarea>` pre‑filled with transcript.text.
   - Style textarea with Tailwind: w-full h-48 p-2 bg-[#2a2a2a] border border-[#444] rounded.
   - Show "Save" and "Cancel" buttons replacing Edit button.
4. Save button: call a `handleSave` function (to be implemented in next task).
5. Cancel button: exit editMode, discard editedText.
6. Ensure word‑by‑word display is hidden while editing (or keep it for reference).
7. Update modal header to show "(Editing)" when in edit mode.

Keep existing copy/download buttons visible but disabled during edit? Optional.
  </action>
  <verify>
- Open transcription modal for a transcribed recording.
- Click Edit button, see textarea appear with transcript text.
- Cancel returns to view mode.
- UI updates appropriately.
  </verify>
  <done>
TranscriptionModal has functional edit mode with textarea and save/cancel buttons.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create backend command to save edited transcript</name>
  <files>src-tauri/src/commands/transcription.rs</files>
  <action>
1. Add a new public function `save_transcript` with #[tauri::command] attribute.
   - Signature: `async fn save_transcript(path: PathBuf, text: String) -> Result<(), String>`
   - `path` is the original audio file path (or transcript path). We'll follow sidecar pattern: `path.with_extension("txt")`.
2. Implementation:
   - Validate path exists (audio file optional).
   - Write `text` to sidecar .txt file (overwrite).
   - Return Ok(()) on success, error string on failure.
3. Register command in `src-tauri/src/lib.rs` invoke_handler (add `save_transcript`).
4. Ensure error mapping: wrap IO errors in user‑friendly strings.

Note: This command does not update the in‑memory Transcript object; frontend will handle that.
  </action>
  <verify>
- Compile Rust project (`cargo check`).
- Test command via Tauri devtools or create a simple test.
- Ensure file is written correctly.
  </verify>
  <done>
Save command compiles, registered, and can write text to sidecar .txt file.
  </done>
</task>

<task type="auto">
  <name>Task 3: Connect edit UI with save command and update state</name>
  <files>src/components/TranscriptionModal.tsx, src/lib/transcription/commands.ts</files>
  <action>
1. In `src/lib/transcription/commands.ts`, add wrapper:
   ```
   export async function saveTranscript(audioPath: string, text: string): Promise<void> {
     return invoke('save_transcript', { path: audioPath, text })
   }
   ```
2. In TranscriptionModal, implement `handleSave`:
   - Call `saveTranscript` with the original audio file path (need to pass it as prop? Currently modal only receives Transcript object. We need to also receive the audio file path. Modify RecordingsList to pass `audioPath` as prop).
   - While saving, show loading indicator (disable save button, spinner).
   - On success: update the transcript object in parent state (RecordingsList) so that the updated text reflects. This may require lifting state up. Simpler: close modal and rely on sidecar file; next time modal opens, it will read from file? Currently modal uses in‑memory transcript from transcriptionStates. We can update that state.
   - Exit editMode.
   - Show success toast.
   - On error: show error toast, stay in edit mode.
3. Update RecordingsList to pass audioPath to TranscriptionModal. Add a prop `audioPath?: string`. When opening modal, set currentAudioPath alongside currentTranscript.
4. Update transcriptionStates when transcript saved: modify the transcript text in state.

Alternative: After saving, refetch transcript from file? Not needed.
  </action>
  <verify>
- Open modal, edit text, click Save.
- Observe toast success and modal returns to view mode with updated text.
- Check sidecar .txt file content matches edited text.
- Verify error handling (e.g., write‑protected location).
  </verify>
  <done>
User can edit transcript text, save changes, and see updated transcript persist.
  </done>
</task>

</tasks>

<verification>
1. Transcribe a recording.
2. Open transcript modal, click Edit.
3. Modify text in textarea, click Save.
4. Confirm toast appears and modal exits edit mode showing updated text.
5. Close modal, reopen transcript for same recording – edited text appears.
6. Check file system: .txt file contains edited text.
</verification>

<success_criteria>
- Transcript editing works end‑to‑end.
- Changes persist across app sessions (saved to file).
- No data loss: original transcript can be recovered from backup? (Not required for MVP).
</success_criteria>

<output>
After completion, create `.planning/phases/02-transcript-management-enhancements/02-02-SUMMARY.md`
</output>